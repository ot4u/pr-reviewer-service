// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package database

import (
	"context"
)

const getActiveUsersByTeam = `-- name: GetActiveUsersByTeam :many
SELECT user_id, username, team_name, is_active 
FROM users 
WHERE team_name = $1 AND is_active = true 
AND user_id != $2  
ORDER BY RANDOM()
LIMIT 2
`

type GetActiveUsersByTeamParams struct {
	TeamName string
	UserID   string
}

func (q *Queries) GetActiveUsersByTeam(ctx context.Context, arg GetActiveUsersByTeamParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getActiveUsersByTeam, arg.TeamName, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TeamName,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersByTeam = `-- name: GetAllUsersByTeam :many
SELECT user_id, username, team_name, is_active 
FROM users 
WHERE team_name = $1
`

func (q *Queries) GetAllUsersByTeam(ctx context.Context, teamName string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersByTeam, teamName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TeamName,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, username, team_name, is_active 
FROM users 
WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.TeamName,
		&i.IsActive,
	)
	return i, err
}

const getUserTeam = `-- name: GetUserTeam :one
SELECT team_name FROM users WHERE user_id = $1
`

func (q *Queries) GetUserTeam(ctx context.Context, userID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserTeam, userID)
	var team_name string
	err := row.Scan(&team_name)
	return team_name, err
}

const updateUserActiveStatus = `-- name: UpdateUserActiveStatus :one
UPDATE users 
SET is_active = $2 
WHERE user_id = $1 
RETURNING user_id, username, team_name, is_active
`

type UpdateUserActiveStatusParams struct {
	UserID   string
	IsActive bool
}

func (q *Queries) UpdateUserActiveStatus(ctx context.Context, arg UpdateUserActiveStatusParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserActiveStatus, arg.UserID, arg.IsActive)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.TeamName,
		&i.IsActive,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (user_id, username, team_name, is_active)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id) 
DO UPDATE SET 
    team_name = EXCLUDED.team_name 
RETURNING user_id, username, team_name, is_active
`

type UpsertUserParams struct {
	UserID   string
	Username string
	TeamName string
	IsActive bool
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, upsertUser,
		arg.UserID,
		arg.Username,
		arg.TeamName,
		arg.IsActive,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.TeamName,
		&i.IsActive,
	)
	return i, err
}
